

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Introduction to GPSat &#8212; GEOL0069 Guide Book</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=365ca57ee442770a23c6" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=365ca57ee442770a23c6" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=365ca57ee442770a23c6" />
  <script src="_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=365ca57ee442770a23c6"></script>

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Chapter_2_Intro_to_GPSat';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="GPSat Along-Track Interpolation" href="Chapter_2_GPSat_along_track-3.html" />
    <link rel="prev" title="Introduction to Gaussian Processes" href="Chapter2_IntrotoGaussianProcesses.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/logo.png" class="logo__image only-light" alt="GEOL0069 Guide Book - Home"/>
    <script>document.write(`<img src="_static/logo.png" class="logo__image only-dark" alt="GEOL0069 Guide Book - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Welcome to GEOL0069 AI for Earth Observation
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Week 1</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Chapter%201%3APreparation.html">Preparation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter%201%3AIRIS.html">Introduction to Intelligently Reinforced Image Segmentation (IRIS)</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Week 2</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Chapter%201%3AML.html">Introduction to AI/Machine Learning</a></li>

<li class="toctree-l1"><a class="reference internal" href="Chapter_1_Sea_ice_and_Lead_Classification.html">Sea-ice and Lead Classification</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter_1_AI_Algorithms.html">AI/Machine Learning Implementation</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Week 3</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Chapter%201%3AFetching_Data.html">Data Fetching</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter_1_rollout_3.html">Roll-out on a Full Image</a></li>





</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Week 4</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Chapter1_Data_Colocating_S2_S3_3.html">Colocating Sentinel-3 OLCI/SRAL and Sentinal-2 Optical Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter1_Unsupervised_Learning_Methods_2.html">Unsupervised Learning</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Week 5</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Chapter1_Regression.html">Regression Techniques for Predictive Analysis</a></li>

<li class="toctree-l1"><a class="reference internal" href="Creating_training_data_fromS3_S2-2.html">Creating Training Data from Sentinel-2 and Sentinel-3 OLCI Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter1_Regression_Part2_2425.html">Application of Regression Techniques in Satellite Imagery Analysis</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Week 6</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Imagery_alignment_intro.html">Imagery Alignment: Introduction and Simple Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="Imagery_alignment_application.html">Images alignment on S3/S2</a></li>
<li class="toctree-l1"><a class="reference internal" href="Creating_training_data_from_aligned_misaligned_imagery.html">Creating Training Data from Aligned and Misaligned Imagery</a></li>
<li class="toctree-l1"><a class="reference internal" href="Regression_Application_MPF_aligned_misaligned_training_data.html">Regression Application on Melt Pond Fractions (MPF)</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Week 7</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Chapter2_IntrotoGaussianProcesses.html">Introduction to Gaussian Processes</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Introduction to GPSat</a></li>




</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Week 8</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Chapter_2_GPSat_along_track-3.html">GPSat Along-Track Interpolation</a></li>




<li class="toctree-l1"><a class="reference internal" href="Chapter_2_SLA_GPSat_eddies.html">Interpolation of Sea Level Anomaly using GPSat</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter_2_SLA_GPSat_GPOD.html">Sea Level Anomaly Interpolation Using GPSat (GPOD)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Eddies_from_altimetry_part1-2.html">Finding Ocean Eddies using Satellite Altimetry: Part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="Eddies_from_altimetry_part2.html">Finding Ocean Eddies using Satellite Altimetry: Part 2</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Week 9</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Week9_XAI.html">Explainable AI</a></li>
<li class="toctree-l1"><a class="reference internal" href="XAI_Part_2_fullwaveform_aligned.html">XAI for Sea Ice Classification of Full Waveform</a></li>
<li class="toctree-l1"><a class="reference internal" href="XAI_Part_2_characteristics.html">XAI for Sea Ice Classification of Waveform Characteristics</a></li>
<li class="toctree-l1"><a class="reference internal" href="XAI_Part_2_characteristics_roughness.html">XAI for Sea Ice Roughness from Waveform</a></li>


</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Week 10</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="final_assessment.html">Potential Project Ideas</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2FChapter_2_Intro_to_GPSat.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/Chapter_2_Intro_to_GPSat.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Introduction to GPSat</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Introduction to GPSat</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#gaussian-processes">Gaussian processes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-likelihood">The likelihood</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#prediction">Prediction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#training">Training</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#using-gpus-to-accelerate-training-and-inference">Using GPUs to accelerate training and inference</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#gpsat-modelling-with-local-gp-experts-a-1-d-case-study-part-1">GPSat modelling with local GP experts: A 1-D case study (Part 1)</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#local-gp-experts">Local GP experts</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#gpsat-modelling-with-local-gp-experts-a-1-d-case-study-part-2">GPSat modelling with local GP experts: A 1-D case study (Part 2)</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#configuration-dataclasses">Configuration dataclasses</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#local-expert-config">1. Local expert config</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#model-config">2. Model config</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#data-config">3. Data config</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#prediction-location-config">4. Prediction location config</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#run-experiment">Run experiment</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-more-local-experts">Using more local experts</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#d-interpolation-of-abc-satellite-data">2D interpolation of ABC satellite data</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#setting-up-configurations">Setting up configurations</a></li>
</ul>
</li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="introduction-to-gpsat">
<h1>Introduction to GPSat<a class="headerlink" href="#introduction-to-gpsat" title="Permalink to this heading">#</a></h1>
<p>The original documentation of GPSat can be accessed <a class="reference external" href="https://cpomucl.github.io/GPSat/">here</a>.
In the previous session, we’ve looked at some basics in Gaussian Processes. As discussed, we will dive into GPSat in this session. Let’s now begin with some recap about the GP basics and get familar with the GPsat Model API to get get/set parameters.</p>
<p>First of all, please run the following code to install GPSat.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>try:
    import google.colab
    IN_COLAB = True
except:
    IN_COLAB = False

# TODO: allow for mounting of gdrive
# TODO: allow for checking out a branch

if IN_COLAB:
    
    import os
    import re

    # change to working directory
    work_dir = &quot;/content&quot;
    
    assert os.path.exists(work_dir), f&quot;workspace directory: {work_dir} does not exist&quot;
    os.chdir(work_dir)
    
    # clone repository
    !git clone https://github.com/CPOMUCL/GPSat.git

    repo_dir = os.path.join(work_dir, &quot;GPSat&quot;)

    print(f&quot;changing directory to: {repo_dir}&quot;)
    os.chdir(repo_dir)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>if IN_COLAB:
    !pip install -r requirements.txt
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>if IN_COLAB:
    !pip install -e .
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">GPSat.models.sklearn_models</span> <span class="kn">import</span> <span class="n">sklearnGPRModel</span>
</pre></div>
</div>
</div>
</div>
<p>Consider data generated from a simple cosine function</p>
<div class="math notranslate nohighlight">
\[
\tag{1}
y = \cos(X) + \epsilon,
\]</div>
<p>where <span class="math notranslate nohighlight">\(X = (x_1, \ldots, x_N)\)</span> is a set of randomly generated points within the interval <span class="math notranslate nohighlight">\([-L, L]\)</span>, and <span class="math notranslate nohighlight">\(\epsilon\)</span> is a measurement error, which we take to be an i.i.d. zero-mean Gaussian noise with standard deviation <span class="math notranslate nohighlight">\(0.05\)</span>.</p>
<p>Our goal is to use a Gaussian process model to filter out the noise <span class="math notranslate nohighlight">\(\epsilon\)</span> and recover the function <span class="math notranslate nohighlight">\(f(x) = \cos(x)\)</span> from the training data <span class="math notranslate nohighlight">\((X, y)\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set random seed</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Generate data</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">noise_std</span> <span class="o">=</span> <span class="mf">0.05</span>

<span class="n">X_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,))</span>
<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">epsilon</span> <span class="o">=</span> <span class="n">noise_std</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">epsilon</span>
<span class="n">f_truth</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X_grid</span><span class="p">)</span> <span class="c1"># Ground truth</span>

<span class="c1"># Plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_truth</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ground truth&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Noisy observations&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<section id="gaussian-processes">
<h2>Gaussian processes<a class="headerlink" href="#gaussian-processes" title="Permalink to this heading">#</a></h2>
<p>Intuitively, a zero-mean Gaussian process (GP) can be understood as a Gaussian distribution on an <em>arbitrary collection of inputs</em>.</p>
<p>More specifically, it is a random function <span class="math notranslate nohighlight">\(f : \mathbb{R} \rightarrow \mathbb{R}\)</span> such that for an arbitrary collection of inputs <span class="math notranslate nohighlight">\(X = (x_1, \ldots, x_N)\)</span>, the random variable <span class="math notranslate nohighlight">\(f(X)\)</span> is a multivariate Gaussian</p>
<div class="math notranslate nohighlight">
\[
f(X) \sim \mathcal{N}(0, K_{XX}),
\]</div>
<p>for some <span class="math notranslate nohighlight">\(N \times N\)</span> covariance matrix <span class="math notranslate nohighlight">\(K_{XX}\)</span>. Importantly, this covariance matrix can be computed using a <strong>kernel function</strong>  <span class="math notranslate nohighlight">\(k : \mathbb{R} \times \mathbb{R} \rightarrow \mathbb{R}\)</span> as</p>
<div class="math notranslate nohighlight">
\[
[K_{XX}]_{ij} = k(x_i, x_j), \quad \forall i,j = 1, \ldots, N,
\]</div>
<p>and this completely characterises the zero-mean GP. i.e. the properties of a GP are completely determined by the kernel!</p>
<p>Below, we set up a GP with the so-called radial basis function (RBF) kernel, given as</p>
<div class="math notranslate nohighlight">
\[
\tag{RBF}
k_{\text{RBF}}(x, x') = \sigma^2 \exp\left(-\frac{|x-x'|^2}{2\ell^2}\right),
\]</div>
<p>using <code class="docutils literal notranslate"><span class="pre">sklearnGPRModel</span></code>, a GPSat GP regression model based on the <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> GPR module.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gpr</span> <span class="o">=</span> <span class="n">sklearnGPRModel</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;RBF&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In the expression for the kernel (RBF) above, we see that it is controlled by two parameters <span class="math notranslate nohighlight">\(\sigma^2\)</span> and <span class="math notranslate nohighlight">\(\ell\)</span>, which are referred to as the <em>kernel variance</em> and the <em>lengthscale</em> hyperparameters respectively (in machine learning lingo, we refer to parameters that define the models as <em>hyperparameters</em>).</p>
<p>Every <code class="docutils literal notranslate"><span class="pre">GPSat</span></code> model comes equipped with a getter/setter method for all (hyper)-parameters in the model. A list of all parameters is stored in the <code class="docutils literal notranslate"><span class="pre">param_names</span></code> property.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">gpr</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can retrieve their values using the <code class="docutils literal notranslate"><span class="pre">get_*()</span></code> method, where <code class="docutils literal notranslate"><span class="pre">*</span></code> is to be substituted with the parameter name.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ls</span> <span class="o">=</span> <span class="n">gpr</span><span class="o">.</span><span class="n">get_lengthscales</span><span class="p">()</span>
<span class="n">kv</span> <span class="o">=</span> <span class="n">gpr</span><span class="o">.</span><span class="n">get_kernel_variance</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lengthscale: </span><span class="si">{</span><span class="n">ls</span><span class="si">}</span><span class="s2">, Kernel variance: </span><span class="si">{</span><span class="n">kv</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Suppose we want to set the kernel variance to 1.5. We can achieve this using the <code class="docutils literal notranslate"><span class="pre">set_*()</span></code> method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gpr</span><span class="o">.</span><span class="n">set_kernel_variance</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">kv</span> <span class="o">=</span> <span class="n">gpr</span><span class="o">.</span><span class="n">get_kernel_variance</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New kernel variance: </span><span class="si">{</span><span class="n">kv</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="the-likelihood">
<h2>The likelihood<a class="headerlink" href="#the-likelihood" title="Permalink to this heading">#</a></h2>
<p>In <code class="docutils literal notranslate"><span class="pre">param_names</span></code> above, we also saw a parameter <code class="docutils literal notranslate"><span class="pre">likelihood_variance</span></code>. This is not a hyperparameter of the GP kernel, but is instead a parameter of the so-called <em>likelihood</em>.</p>
<p>In general, the likelihood describes the probability of an observation <span class="math notranslate nohighlight">\(y\)</span> given the ground truth field <span class="math notranslate nohighlight">\(f(X)\)</span>, i.e., the conditional distribution <span class="math notranslate nohighlight">\(p(y | f(X))\)</span>. In our case, since the observations are assumed to only differ from the ground truth by some measurement error, the likelihood is understood as modelling precisely this measurement error.</p>
<p>From (1), we see that the likelihood is given by</p>
<div class="math notranslate nohighlight">
\[
p(y | f(X)) \sim \mathcal{N}(f(X), \alpha^2 I),
\]</div>
<p>with <span class="math notranslate nohighlight">\(\alpha = 0.05\)</span> and <span class="math notranslate nohighlight">\(f(x) = \cos(x)\)</span>. Here, the parameter <span class="math notranslate nohighlight">\(\alpha^2\)</span> is referred to as the <em>likelihood variance</em>.</p>
<p>We can get the default value for the likelihood variance using the <code class="docutils literal notranslate"><span class="pre">get_*</span></code> method:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Likelihood variance: </span><span class="si">{</span><span class="n">gpr</span><span class="o">.</span><span class="n">get_likelihood_variance</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>and set the correct value by using the <code class="docutils literal notranslate"><span class="pre">set_*</span></code> method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">gpr</span><span class="o">.</span><span class="n">set_likelihood_variance</span><span class="p">(</span><span class="n">alpha</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New likelihood variance: </span><span class="si">{</span><span class="n">gpr</span><span class="o">.</span><span class="n">get_likelihood_variance</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Alternatively, we could have also initialised the GPR model by specifying the <code class="docutils literal notranslate"><span class="pre">likelihood_variance</span></code> and <code class="docutils literal notranslate"><span class="pre">kernel_variance</span></code> arguments with their respective values.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># This initialises a GP model with the desired values</span>
<span class="n">gpr</span> <span class="o">=</span> <span class="n">sklearnGPRModel</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;RBF&#39;</span><span class="p">,</span> <span class="n">likelihood_variance</span><span class="o">=</span><span class="n">alpha</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">kernel_variance</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">ls</span> <span class="o">=</span> <span class="n">gpr</span><span class="o">.</span><span class="n">get_lengthscales</span><span class="p">()</span>
<span class="n">kv</span> <span class="o">=</span> <span class="n">gpr</span><span class="o">.</span><span class="n">get_kernel_variance</span><span class="p">()</span>
<span class="n">lv</span> <span class="o">=</span> <span class="n">gpr</span><span class="o">.</span><span class="n">get_likelihood_variance</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lengthscale: </span><span class="si">{</span><span class="n">ls</span><span class="si">}</span><span class="s2">,  Kernel variance: </span><span class="si">{</span><span class="n">kv</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">,  Likelihood variance: </span><span class="si">{</span><span class="n">lv</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="prediction">
<h2>Prediction<a class="headerlink" href="#prediction" title="Permalink to this heading">#</a></h2>
<p>From just these information, we can now infer what our ground truth function <span class="math notranslate nohighlight">\(f\)</span> should be, given the data pair <span class="math notranslate nohighlight">\((X, y)\)</span>.</p>
<p>Mathematically this is achieved by the simple, yet powerful <strong>Bayes’ rule</strong> to update our belief on the function <span class="math notranslate nohighlight">\(f\)</span> given our data <span class="math notranslate nohighlight">\((X, y)\)</span>. Informally, this reads:</p>
<div class="math notranslate nohighlight">
\[
\tag{2}
\underbrace{p(f \,|\, X, y)}_{\text{posterior}} \propto \underbrace{p(y \,|\, f(X))}_{\text{likelihood}} \,\, \underbrace{p(f)}_{\text{prior}}.
\]</div>
<p>In GP regression, one can understand the GP as modelling a prior distribution on the function <span class="math notranslate nohighlight">\(f\)</span>. Thus, the term <span class="math notranslate nohighlight">\(p(f)\)</span> corresponds to our GP model. The posterior distribution <span class="math notranslate nohighlight">\(p(f | X, y)\)</span> thus gives our prediction of the field <span class="math notranslate nohighlight">\(f\)</span> given the data.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">GPSat</span></code> models, this is computed using the <code class="docutils literal notranslate"><span class="pre">predict()</span></code> method. This takes as inputs a set of <span class="math notranslate nohighlight">\(N_*\)</span> prediction points, which must be an array of size <span class="math notranslate nohighlight">\((N_*, D)\)</span>, where <span class="math notranslate nohighlight">\(D\)</span> is the input dimension (in our case, just 1).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make predictions on a uniform grid</span>
<span class="n">pred_dict</span> <span class="o">=</span> <span class="n">gpr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># Extract the mean and variance from the results dictionary</span>
<span class="n">f_mean</span> <span class="o">=</span> <span class="n">pred_dict</span><span class="p">[</span><span class="s1">&#39;f*&#39;</span><span class="p">]</span>
<span class="n">f_var</span> <span class="o">=</span> <span class="n">pred_dict</span><span class="p">[</span><span class="s1">&#39;f*_var&#39;</span><span class="p">]</span>
<span class="n">f_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f_var</span><span class="p">)</span>

<span class="c1"># Plot results</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_truth</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ground truth&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_mean</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;GP Prediction&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_mean</span><span class="o">-</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std</span><span class="p">,</span> <span class="n">f_mean</span><span class="o">+</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Noisy observations&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>In the plot above, we have plotted the prediction in blue, where the shaded region indicates a 90% credible interval, where we believe the ground truth lies.</p>
<p>To assess the quality of this prediction, we can look at two metrics:</p>
<p>(1) the mean squared error <span class="math notranslate nohighlight">\(\frac{1}{N_*} \sum_{n=1}^{N^*} (f_{truth}(x_n') - f_{mean}(x_n'))^2\)</span> between the predictive mean and the ground truth, and</p>
<p>(2) the mean log-likelihood <span class="math notranslate nohighlight">\(\frac{1}{N_*} \sum_{n=1}^{N^*} \log \mathcal{N}(f_{truth}(x_n') \,|\, f_{mean}(x_n'), f_{std}(x_n')^2)\)</span> of the ground truth given the predictive mean and standard deviation.</p>
<p>The former only assess the quality of the mean, however the latter also assess the quality of the predictive uncertainty. For the log-likelihood loss, a higher value indicates better performance.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean squared error: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">f_truth</span> <span class="o">-</span> <span class="n">f_mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean log likelihood: </span><span class="si">{</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">f_truth</span><span class="p">,</span> <span class="n">f_mean</span><span class="p">,</span> <span class="n">f_std</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="training">
<h2>Training<a class="headerlink" href="#training" title="Permalink to this heading">#</a></h2>
<p>To further improve our predictions, we can think of finding a value for the hyperparameters <span class="math notranslate nohighlight">\(\Theta = (\sigma^2, \ell, \alpha^2)\)</span> that fit the data “better”. This is called the <em>training</em> process.</p>
<p>To define what a “better” model means, we can compare them using a certain metric. A perferred such metric in Bayesian modelling is the so-called <em>marginal likelihood</em>, defined as:</p>
<div class="math notranslate nohighlight">
\[
\tag{3}
p(y | \Theta)  = \int p(y | f(X), \Theta) \,p(f(X) | \Theta) \,df(X).
\]</div>
<p>Thus, we can find an optimal set of parameters by maximising (3) with respect to <span class="math notranslate nohighlight">\(\Theta\)</span>. Equivalently, we can also maximise their log-transformed counterpart, which is more typically used.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">GPSat</span></code> models, we can compute the log-transformed version of the metric (3) by simply calling the <code class="docutils literal notranslate"><span class="pre">get_objective_function_value()</span></code> method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;log marginal likelihood = </span><span class="si">{</span><span class="n">gpr</span><span class="o">.</span><span class="n">get_objective_function_value</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now, let’s optimise this loss function, which can be achieved in <code class="docutils literal notranslate"><span class="pre">GPSat</span></code> model by calling the <code class="docutils literal notranslate"><span class="pre">optimise_parameters()</span></code> method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Optimise model</span>
<span class="n">opt_success</span> <span class="o">=</span> <span class="n">gpr</span><span class="o">.</span><span class="n">optimise_parameters</span><span class="p">()</span>

<span class="c1"># Print outputs</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimise success: </span><span class="si">{</span><span class="n">opt_success</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
<span class="n">param_dict</span> <span class="o">=</span> <span class="n">gpr</span><span class="o">.</span><span class="n">get_parameters</span><span class="p">(</span><span class="o">*</span><span class="n">gpr</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Values of model hyperparameters after training:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> : </span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;log marginal likelihood (after training) = </span><span class="si">{</span><span class="n">gpr</span><span class="o">.</span><span class="n">get_objective_function_value</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We see that after training, the values of the lengthscale and kernel variance hyperparameters have changed. In addition, the log marginal likelihood value has increased.</p>
<p><strong>Note:</strong> For scikit-learn models, the likelihood variance is assumed constant and does not get optimised. If you want to optimise the likelihood variance, use e.g. <code class="docutils literal notranslate"><span class="pre">GPSat.models.gpflow_models.GPflowGPRModel</span></code> instead.</p>
<p>Now let’s see the updated predictions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Predict again</span>
<span class="n">pred_dict</span> <span class="o">=</span> <span class="n">gpr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_grid</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span>

<span class="c1"># Extract mean, variance and standard deviation</span>
<span class="n">f_mean</span> <span class="o">=</span> <span class="n">pred_dict</span><span class="p">[</span><span class="s1">&#39;f*&#39;</span><span class="p">]</span>
<span class="n">f_var</span> <span class="o">=</span> <span class="n">pred_dict</span><span class="p">[</span><span class="s1">&#39;f*_var&#39;</span><span class="p">]</span>
<span class="n">f_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f_var</span><span class="p">)</span>

<span class="c1"># Plot predictions</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_truth</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ground truth&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_mean</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;GP Prediction&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_mean</span><span class="o">-</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std</span><span class="p">,</span> <span class="n">f_mean</span><span class="o">+</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Noisy observations&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We see that the uncertainty bounds are now tighter around the ground truth after training, although the mean prediction is a little bit more off than before.</p>
<p>This is reflected in the metrics:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean squared error: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">f_truth</span> <span class="o">-</span> <span class="n">f_mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean log likelihood: </span><span class="si">{</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">f_truth</span><span class="p">,</span> <span class="n">f_mean</span><span class="p">,</span> <span class="n">f_std</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="using-gpus-to-accelerate-training-and-inference">
<h1>Using GPUs to accelerate training and inference<a class="headerlink" href="#using-gpus-to-accelerate-training-and-inference" title="Permalink to this heading">#</a></h1>
<p>Now, with some basics knowledge in Gaussian Processes, we will see the advantages of using GPUs to do training and inference on GP.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">GPSat.models.sklearn_models</span> <span class="kn">import</span> <span class="n">sklearnGPRModel</span>
<span class="kn">from</span> <span class="nn">GPSat.models.gpflow_models</span> <span class="kn">import</span> <span class="n">GPflowGPRModel</span>
</pre></div>
</div>
</div>
</div>
<p>For the experiment, we use the same model as before but sampling more data points.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set random seed</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Generate data</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">2500</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">noise_std</span> <span class="o">=</span> <span class="mf">0.05</span>

<span class="n">X_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,))</span>
<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">epsilon</span> <span class="o">=</span> <span class="n">noise_std</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">epsilon</span>
<span class="n">f_truth</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X_grid</span><span class="p">)</span> <span class="c1"># Ground truth</span>

<span class="c1"># Plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_truth</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ground truth&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Noisy observations&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>As before, we model this data using <code class="docutils literal notranslate"><span class="pre">sklearnGPRModel</span></code>. Scikit-learn does not have GPU support so this will do all the training and prediciton on CPU, even if it detects GPUs on the machine.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># ---------------</span>
<span class="c1"># Training on CPU</span>
<span class="c1"># ---------------</span>

<span class="c1"># Initialise sklearn GPR model</span>
<span class="n">sklearn_gpr</span> <span class="o">=</span> <span class="n">sklearnGPRModel</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;RBF&#39;</span><span class="p">,</span> <span class="n">likelihood_variance</span><span class="o">=</span><span class="n">noise_std</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Train model</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">sklearn_gpr</span><span class="o">.</span><span class="n">optimise_parameters</span><span class="p">()</span>

<span class="c1"># Predict on test points</span>
<span class="n">pred_dict_sklearn</span> <span class="o">=</span> <span class="n">sklearn_gpr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_grid</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Now, let’s use <code class="docutils literal notranslate"><span class="pre">GPflowGPRModel</span></code> to model the same data, which is based on the python package <code class="docutils literal notranslate"><span class="pre">GPflow</span></code>, itself a tensorflow based package for modelling with GPs. This automatically does the training and prediction on GPUs, if available.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># ---------------</span>
<span class="c1"># Training on GPU</span>
<span class="c1"># ---------------</span>

<span class="c1"># Initialise GPflow GPR model</span>
<span class="n">gpflow_gpr</span> <span class="o">=</span> <span class="n">GPflowGPRModel</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;RBF&#39;</span><span class="p">,</span> <span class="n">noise_variance</span><span class="o">=</span><span class="n">noise_std</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Train model</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">gpflow_gpr</span><span class="o">.</span><span class="n">optimise_parameters</span><span class="p">(</span><span class="n">fixed_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;likelihood_variance&#39;</span><span class="p">])</span>

<span class="c1"># Predict on test points</span>
<span class="n">pred_dict_gpflow</span> <span class="o">=</span> <span class="n">gpflow_gpr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_grid</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Note:</strong> In <code class="docutils literal notranslate"><span class="pre">GPflowGPRModel</span></code>, the likelihood variance is initialised with the argument <code class="docutils literal notranslate"><span class="pre">noise_variance</span></code> instead of <code class="docutils literal notranslate"><span class="pre">likelihood_variance</span></code> as in <code class="docutils literal notranslate"><span class="pre">sklearnGPRModel</span></code>. Note also that since likelihood variance is a trainable parameter in <code class="docutils literal notranslate"><span class="pre">GPflowGPRModel</span></code>, we pass an additional argument <code class="docutils literal notranslate"><span class="pre">fixed_params</span> <span class="pre">=</span> <span class="pre">['likelihood_variance']</span></code> to the <code class="docutils literal notranslate"><span class="pre">optimise_parameters()</span></code> method to freeze the assigned likelhood variance value. For more details, see the API references for both models.</p>
<p>We see that training time is much shorter on a GPU than on CPU, which is where most of the computation takes place in the enitre GP workflow. Hence, when we have a large dataset, it is advantageous to use GPUs over CPUs.</p>
<p>We can also check that the results of the two predictions are near identical:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Extract mean and variance for the sklearn prediction</span>
<span class="n">f_mean_sklearn</span> <span class="o">=</span> <span class="n">pred_dict_sklearn</span><span class="p">[</span><span class="s1">&#39;f*&#39;</span><span class="p">]</span>
<span class="n">f_var_sklearn</span> <span class="o">=</span> <span class="n">pred_dict_sklearn</span><span class="p">[</span><span class="s1">&#39;f*_var&#39;</span><span class="p">]</span>
<span class="n">f_std_sklearn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f_var_sklearn</span><span class="p">)</span>

<span class="c1"># Extract mean and variance for the gpflow prediction</span>
<span class="n">f_mean_gpflow</span> <span class="o">=</span> <span class="n">pred_dict_gpflow</span><span class="p">[</span><span class="s1">&#39;f*&#39;</span><span class="p">]</span>
<span class="n">f_var_gpflow</span> <span class="o">=</span> <span class="n">pred_dict_gpflow</span><span class="p">[</span><span class="s1">&#39;f*_var&#39;</span><span class="p">]</span>
<span class="n">f_std_gpflow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f_var_gpflow</span><span class="p">)</span>

<span class="c1"># Plot results</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_truth</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ground truth&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_mean_sklearn</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;sklearn Prediction&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_mean_sklearn</span><span class="o">-</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std_sklearn</span><span class="p">,</span> <span class="n">f_mean_sklearn</span><span class="o">+</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std_sklearn</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_mean_gpflow</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;gpflow Prediction&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_mean_gpflow</span><span class="o">-</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std_gpflow</span><span class="p">,</span> <span class="n">f_mean_gpflow</span><span class="o">+</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std_gpflow</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="gpsat-modelling-with-local-gp-experts-a-1-d-case-study-part-1">
<h1>GPSat modelling with local GP experts: A 1-D case study (Part 1)<a class="headerlink" href="#gpsat-modelling-with-local-gp-experts-a-1-d-case-study-part-1" title="Permalink to this heading">#</a></h1>
<p>The main intended use case of <code class="docutils literal notranslate"><span class="pre">GPSat</span></code> is to model complex looking fields from a large set of data points, a situation commonly encountered in the geosciences, namely optimal interpolation (OI). The strategy that we adopted is quite simple: to model local chunks of data using different GPs and then gluing their predictions together.</p>
<p>In this tutorial notebook, we will see how this method performs compared to a single “global” GP. We note that <code class="docutils literal notranslate"><span class="pre">GPSat</span></code> has an automated API to carry out this whole workflow, which we will see in the second part of this tutorial. However for the sake of understanding, we will hard-code this method here.</p>
<p>First, we generate noisy data as follows:</p>
<div class="math notranslate nohighlight">
\[
\tag{1}
y = \sin(1/X) + \epsilon, \quad \epsilon \sim \mathcal{N}(0, 0.05^2 I),
\]</div>
<p>in the region <span class="math notranslate nohighlight">\(X \in [0.1, 0.6]\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set random seed</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Generate data</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">noise_std</span> <span class="o">=</span> <span class="mf">0.05</span>

<span class="n">X_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,))</span>
<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
<span class="n">epsilon</span> <span class="o">=</span> <span class="n">noise_std</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">epsilon</span>
<span class="n">f_truth</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X_grid</span><span class="p">)</span> <span class="c1"># Ground truth</span>

<span class="c1"># Plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_truth</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ground truth&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Noisy observations&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>This function is tricky to model well as the variability of the curve varies depending on where you are (shorter lengthscales near 0 and longer lengthscales near 1).</p>
<p>Let’s first see how a standard GP fits on this data.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialise sklearn GPR model</span>
<span class="n">gpr</span> <span class="o">=</span> <span class="n">sklearnGPRModel</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;RBF&#39;</span><span class="p">,</span> <span class="n">likelihood_variance</span><span class="o">=</span><span class="n">noise_std</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Train model</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">gpr</span><span class="o">.</span><span class="n">optimise_parameters</span><span class="p">()</span>

<span class="c1"># Predict on test locations</span>
<span class="n">pred_dict</span> <span class="o">=</span> <span class="n">gpr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_grid</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span>

<span class="c1"># Extract mean and variance of predictions</span>
<span class="n">f_mean</span> <span class="o">=</span> <span class="n">pred_dict</span><span class="p">[</span><span class="s1">&#39;f*&#39;</span><span class="p">]</span>
<span class="n">f_var</span> <span class="o">=</span> <span class="n">pred_dict</span><span class="p">[</span><span class="s1">&#39;f*_var&#39;</span><span class="p">]</span>
<span class="n">f_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f_var</span><span class="p">)</span>

<span class="c1"># Plot results</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_truth</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ground truth&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_mean</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;sklearn GPR prediction&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_mean</span><span class="o">-</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std</span><span class="p">,</span> <span class="n">f_mean</span><span class="o">+</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We see that the model fits quite well near 0.1, however as it approaches 0.6, we start to see some spurious fluctuations that does not exist in the ground truth field.</p>
<p>Checking the learned lengthscale,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lengthscale: </span><span class="si">{</span><span class="n">gpr</span><span class="o">.</span><span class="n">get_lengthscales</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>it is quite short, which explains the rapid fluctuations.</p>
<p>Let us also check the mean squared error and the log-likelihood loss from the ground truth field for future reference.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean squared error: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">f_truth</span> <span class="o">-</span> <span class="n">f_mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean log likelihood: </span><span class="si">{</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">f_truth</span><span class="p">,</span> <span class="n">f_mean</span><span class="p">,</span> <span class="n">f_std</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<section id="local-gp-experts">
<h2>Local GP experts<a class="headerlink" href="#local-gp-experts" title="Permalink to this heading">#</a></h2>
<p>Next, let us consider a natural idea to solve this issue by fitting different GPs (called <em>local experts</em>) on different regions of the domain. For simplicity, we will use two GP experts: one to model the data for smaller values of <span class="math notranslate nohighlight">\(X\)</span> and another to model the data for larger values of <span class="math notranslate nohighlight">\(X\)</span>.</p>
<p>We assign the following data to the two GPs (call it GP1 and GP2):</p>
<ul class="simple">
<li><p>GP1 gets assigned data points within the interval [0.1, 0.4] and makes predictions in the same region.</p></li>
<li><p>GP2 gets assigned data points within the interval [0.3, 0.6] and makes predictions in the same region.</p></li>
</ul>
<p>Note that we deliberately let the two regions overlap, which will be useful later.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Data points assigned to GP1 and GP2</span>
<span class="n">Data1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mf">0.4</span><span class="p">])</span>
<span class="n">Data2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">])</span>

<span class="c1"># Prediction points assigned to GP1 and GP2</span>
<span class="n">X_test_1</span> <span class="o">=</span> <span class="n">X_grid</span><span class="p">[</span><span class="n">X_grid</span> <span class="o">&lt;</span> <span class="mf">0.4</span><span class="p">]</span>
<span class="n">X_test_2</span> <span class="o">=</span> <span class="n">X_grid</span><span class="p">[</span><span class="n">X_grid</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>By convention, we will associate each region ([0.1, 0.4] and [0.3, 0.6]) by their mid-points (0.25 and 0.45 respectively), and refer to them as the <em>local expert locations</em>.</p>
<p>The distance from the local expert location to the boundary of the region where data points are assigned is referred to as the <em>training radius</em>. In this case, we can check that our two experts both have a training radius of 0.15.</p>
<p>Likewise, the distance from the local expert location to the boundary of the region where prediction points are assigned is referred to as the <em>inference radius</em>. In our case, we have set the inference radius to be equal to the training radius.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set expert locations</span>
<span class="n">xpert_loc_1</span> <span class="o">=</span> <span class="mf">0.25</span>
<span class="n">xpert_loc_2</span> <span class="o">=</span> <span class="mf">0.45</span>

<span class="c1"># Set training and inference radii</span>
<span class="n">training_radius</span> <span class="o">=</span> <span class="n">inference_radius</span> <span class="o">=</span> <span class="mf">0.15</span>
</pre></div>
</div>
</div>
</div>
<p>Now we train GP1 and GP2 in their respective regions and make predictions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Train and predict with GP1</span>
<span class="n">gp1</span> <span class="o">=</span> <span class="n">sklearnGPRModel</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">Data1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">obs</span><span class="o">=</span><span class="n">Data1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;RBF&#39;</span><span class="p">,</span> <span class="n">likelihood_variance</span><span class="o">=</span><span class="n">noise_std</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">gp1</span><span class="o">.</span><span class="n">optimise_parameters</span><span class="p">()</span>
<span class="n">pred_dict_1</span> <span class="o">=</span> <span class="n">gp1</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_1</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span>
<span class="n">f_mean_1</span> <span class="o">=</span> <span class="n">pred_dict_1</span><span class="p">[</span><span class="s1">&#39;f*&#39;</span><span class="p">]</span>
<span class="n">f_var_1</span> <span class="o">=</span> <span class="n">pred_dict_1</span><span class="p">[</span><span class="s1">&#39;f*_var&#39;</span><span class="p">]</span>
<span class="n">f_std_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f_var_1</span><span class="p">)</span>

<span class="c1"># Train and predict with GP2</span>
<span class="n">gp2</span> <span class="o">=</span> <span class="n">sklearnGPRModel</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">Data2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">obs</span><span class="o">=</span><span class="n">Data2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;RBF&#39;</span><span class="p">,</span> <span class="n">likelihood_variance</span><span class="o">=</span><span class="n">noise_std</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">gp2</span><span class="o">.</span><span class="n">optimise_parameters</span><span class="p">()</span>
<span class="n">pred_dict_2</span> <span class="o">=</span> <span class="n">gp2</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_2</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span>
<span class="n">f_mean_2</span> <span class="o">=</span> <span class="n">pred_dict_2</span><span class="p">[</span><span class="s1">&#39;f*&#39;</span><span class="p">]</span>
<span class="n">f_var_2</span> <span class="o">=</span> <span class="n">pred_dict_2</span><span class="p">[</span><span class="s1">&#39;f*_var&#39;</span><span class="p">]</span>
<span class="n">f_std_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f_var_2</span><span class="p">)</span>

</pre></div>
</div>
</div>
</div>
<p>Below, we plot the predictions from the two GPs over-layed on top of one another.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot results</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_truth</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ground truth&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_test_1</span><span class="p">,</span> <span class="n">f_mean_1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Local expert 1&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">X_test_1</span><span class="p">,</span> <span class="n">f_mean_1</span><span class="o">-</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std_1</span><span class="p">,</span> <span class="n">f_mean_1</span><span class="o">+</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std_1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_test_2</span><span class="p">,</span> <span class="n">f_mean_2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Local expert 2&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">X_test_2</span><span class="p">,</span> <span class="n">f_mean_2</span><span class="o">-</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std_2</span><span class="p">,</span> <span class="n">f_mean_2</span><span class="o">+</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std_2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>As expected, we find that GP1 fits the data with a shorter lengthscale and GP2 fits the data with a longer lengthscale.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lengthscale of GP1: </span><span class="si">{</span><span class="n">gp1</span><span class="o">.</span><span class="n">get_lengthscales</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lengthscale of GP2: </span><span class="si">{</span><span class="n">gp2</span><span class="o">.</span><span class="n">get_lengthscales</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can now use the <code class="docutils literal notranslate"><span class="pre">glue_local_predictions_1d()</span></code> method from the <code class="docutils literal notranslate"><span class="pre">GPSat.postprocessing</span></code> module to glue the two predictions smoothly to yield a single prediction.</p>
<p>This is achieved by a gating mechanism, which considers a Gaussian-weighted average of the two predictions.</p>
<p>First, we record our results into a pandas dataframe as follows. This dataframe should have as columns (1) the prediction locations, (2) local expert locations, and (3) any results we wish to glue such as the predicted mean and variance.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">GPSat.postprocessing</span> <span class="kn">import</span> <span class="n">glue_local_predictions_1d</span>

<span class="c1"># Prediction locations for GP1 + GP2</span>
<span class="n">pred_locs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">X_test_1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">X_test_2</span><span class="p">)</span>

<span class="c1"># Expert locations for GP1 + GP2</span>
<span class="n">expert_locs</span> <span class="o">=</span> <span class="p">[</span><span class="n">xpert_loc_1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">X_test_1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">xpert_loc_2</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">X_test_2</span><span class="p">]</span>

<span class="c1"># Predictions from GP1 + GP2</span>
<span class="n">f_mean</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f_mean_1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">f_mean_2</span><span class="p">)</span>
<span class="n">f_var</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f_var_1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">f_var_2</span><span class="p">)</span>

<span class="c1"># Put these information together into a dataframe</span>
<span class="n">results_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;pred_locs&#39;</span><span class="p">:</span> <span class="n">pred_locs</span><span class="p">,</span> <span class="s1">&#39;xprt_locs&#39;</span><span class="p">:</span> <span class="n">expert_locs</span><span class="p">,</span> <span class="s1">&#39;f_mean&#39;</span><span class="p">:</span> <span class="n">f_mean</span><span class="p">,</span> <span class="s1">&#39;f_var&#39;</span><span class="p">:</span> <span class="n">f_var</span><span class="p">})</span>

<span class="nb">print</span><span class="p">(</span><span class="n">results_df</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">*</span><span class="mi">20</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">*</span><span class="mi">20</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">results_df</span><span class="o">.</span><span class="n">tail</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<p>We can now glue local predictions by running <code class="docutils literal notranslate"><span class="pre">glue_local_predictions_1d()</span></code>. This returns a dataframe containing the results of a single <em>glued prediction</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Glue predictions</span>
<span class="n">glued_preds</span> <span class="o">=</span> <span class="n">glue_local_predictions_1d</span><span class="p">(</span><span class="n">preds_df</span> <span class="o">=</span> <span class="n">results_df</span><span class="p">,</span>                  <span class="c1"># The dataframe where results are stored</span>
                                        <span class="n">pred_loc_col</span> <span class="o">=</span> <span class="s1">&#39;pred_locs&#39;</span><span class="p">,</span>             <span class="c1"># The column in dataframe corresponding to the prediction locations</span>
                                        <span class="n">xprt_loc_col</span> <span class="o">=</span> <span class="s1">&#39;xprt_locs&#39;</span><span class="p">,</span>             <span class="c1"># The column in dataframe corresponding to the local expert locations</span>
                                        <span class="n">vars_to_glue</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;f_mean&#39;</span><span class="p">,</span> <span class="s1">&#39;f_var&#39;</span><span class="p">],</span>     <span class="c1"># The columns in dataframe corresponding to the predictions</span>
                                        <span class="n">inference_radius</span> <span class="o">=</span> <span class="n">inference_radius</span><span class="p">)</span>    <span class="c1"># The inference radius (by passing a single float, it is assumed to be equal for both regions)</span>

<span class="n">glued_preds</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Finally we plot the results of this glued prediction.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Extract mean and variance of glued prediction</span>
<span class="n">f_mean</span> <span class="o">=</span> <span class="n">glued_preds</span><span class="p">[</span><span class="s2">&quot;f_mean&quot;</span><span class="p">]</span>
<span class="n">f_var</span> <span class="o">=</span> <span class="n">glued_preds</span><span class="p">[</span><span class="s2">&quot;f_var&quot;</span><span class="p">]</span>
<span class="n">f_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f_var</span><span class="p">)</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">glued_preds</span><span class="p">[</span><span class="s1">&#39;pred_locs&#39;</span><span class="p">]</span>

<span class="c1"># Plot results</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_truth</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ground truth&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">f_mean</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Glued predictions&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">f_mean</span><span class="o">-</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std</span><span class="p">,</span> <span class="n">f_mean</span><span class="o">+</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>The result of the glued prediction looks slightly better than our first attempt using a global GP. This improvement is also reflected in the metrics, with a slightly improved log-likelihood score:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean squared error: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">f_truth</span> <span class="o">-</span> <span class="n">f_mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean log likelihood: </span><span class="si">{</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">f_truth</span><span class="p">,</span> <span class="n">f_mean</span><span class="p">,</span> <span class="n">f_std</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="gpsat-modelling-with-local-gp-experts-a-1-d-case-study-part-2">
<h1>GPSat modelling with local GP experts: A 1-D case study (Part 2)<a class="headerlink" href="#gpsat-modelling-with-local-gp-experts-a-1-d-case-study-part-2" title="Permalink to this heading">#</a></h1>
<p>In the previous part of the tutorial, we implemented a local GP expert model to fit on non-stationary data. Here, we will do the same except using <code class="docutils literal notranslate"><span class="pre">GPSat</span></code>’s <code class="docutils literal notranslate"><span class="pre">LocalExpertOI</span></code> class, which automates some of the procedures involved making experiments less cumbersome.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">GPSat</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">GPSat</span> <span class="kn">import</span> <span class="n">get_parent_path</span>
<span class="kn">from</span> <span class="nn">GPSat.postprocessing</span> <span class="kn">import</span> <span class="n">glue_local_predictions_1d</span>
</pre></div>
</div>
</div>
</div>
<p>We generate the same data as before:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set random seed</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Generate data</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">noise_std</span> <span class="o">=</span> <span class="mf">0.05</span>

<span class="n">X_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,))</span>
<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
<span class="n">epsilon</span> <span class="o">=</span> <span class="n">noise_std</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">epsilon</span>
<span class="n">f_truth</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X_grid</span><span class="p">)</span> <span class="c1"># Ground truth</span>

<span class="c1"># Plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_truth</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ground truth&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Noisy observations&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<section id="configuration-dataclasses">
<h2>Configuration dataclasses<a class="headerlink" href="#configuration-dataclasses" title="Permalink to this heading">#</a></h2>
<p>We will now conduct the same experiments as in the previous tutorial using <code class="docutils literal notranslate"><span class="pre">GPSat.local_experts.LocalExpertOI</span></code>.</p>
<p>First, we break down a single experiment into the following four key components:</p>
<ol class="arabic simple">
<li><p>The local expert locations</p></li>
<li><p>The GP model assigned to each local expert</p></li>
<li><p>The training data</p></li>
<li><p>The points where we want to make predictions</p></li>
</ol>
<p>In <code class="docutils literal notranslate"><span class="pre">GPSat</span></code>, we configure each of these four components with a so-called <em>configuration dataclass</em>. The goal is to allow sufficient modelling flexibility to accomodate various problems and datasets.</p>
<section id="local-expert-config">
<h3>1. Local expert config<a class="headerlink" href="#local-expert-config" title="Permalink to this heading">#</a></h3>
<p>We start by setting the configuration for the local expert locations. This can be done by assigning a dataframe containing the locations of the local experts.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">GPSat.config_dataclasses</span> <span class="kn">import</span> <span class="n">DataConfig</span><span class="p">,</span> <span class="n">ModelConfig</span><span class="p">,</span> <span class="n">PredictionLocsConfig</span><span class="p">,</span> <span class="n">ExpertLocsConfig</span>

<span class="c1"># Construct a data frame containing the two local expert locations</span>
<span class="n">xpert_loc_1</span> <span class="o">=</span> <span class="mf">0.25</span>
<span class="n">xpert_loc_2</span> <span class="o">=</span> <span class="mf">0.45</span>
<span class="n">xpert_locs_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">xpert_loc_1</span><span class="p">,</span> <span class="n">xpert_loc_2</span><span class="p">]})</span>

<span class="c1"># Set up an expert location configuration dataclass</span>
<span class="n">expert_loc_config</span> <span class="o">=</span> <span class="n">ExpertLocsConfig</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">xpert_locs_df</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">source</span></code> argument is where we point to the expert locations. In this case, we simply used a dataframe to represent the expert locations and pointed to that. However in more advanced applications, we also have the functionality to instead point to a file where the expert locations are saved, which can be more convenient.</p>
</section>
<section id="model-config">
<h3>2. Model config<a class="headerlink" href="#model-config" title="Permalink to this heading">#</a></h3>
<p>Next, we set up the configuration for the model assigned to each local expert. Here, we will use the <code class="docutils literal notranslate"><span class="pre">sklearnGPRModel</span></code>, which we specify as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up configuration for the model</span>
<span class="n">model_config</span> <span class="o">=</span> <span class="n">ModelConfig</span><span class="p">(</span><span class="n">oi_model</span><span class="o">=</span><span class="s2">&quot;sklearnGPRModel&quot;</span><span class="p">,</span>
                           <span class="n">init_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;likelihood_variance&quot;</span><span class="p">:</span> <span class="n">noise_std</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                                        <span class="s2">&quot;kernel&quot;</span><span class="p">:</span> <span class="s1">&#39;RBF&#39;</span><span class="p">,</span>
                                        <span class="s2">&quot;verbose&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
                           <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We specified the model we are using in <code class="docutils literal notranslate"><span class="pre">oi_model</span></code> (pre-implemented <code class="docutils literal notranslate"><span class="pre">GPSat</span></code> models can be referred to by strings), and in <code class="docutils literal notranslate"><span class="pre">init_params</span></code>, we pass any arguments used to initialise the model (expressed as a dictionary). Note that we <em>do not need</em> to specify arguments to set the data here (namely <code class="docutils literal notranslate"><span class="pre">data</span></code>, <code class="docutils literal notranslate"><span class="pre">coords</span></code> and <code class="docutils literal notranslate"><span class="pre">obs</span></code>) as this will be done automatically in the main loop.</p>
<p>There are also functionalities to specify constraints on parameters, re-scale the data, etc… however, we will ignore these for the sake of keeping the presentation simple.</p>
</section>
<section id="data-config">
<h3>3. Data config<a class="headerlink" href="#data-config" title="Permalink to this heading">#</a></h3>
<p>Next we set up the configuration for data. Here, we configure information such as the source of data and instructions on how to assign a subset of the data to each local expert.</p>
<p>First, we put our training data into a pandas dataframe.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Write data as dataframe</span>
<span class="n">data_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>

<span class="n">data_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>For the local data selection, we want to select data points within ± the training radius from the expert locations.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">GPSat</span></code>, we have a unique API to select data from simple instructions. These instructions are expressed in a dictionary with the keys <code class="docutils literal notranslate"><span class="pre">&quot;col&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;comp&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;val&quot;</span></code>. For example, see below for the instructions to select data within ± the inference radius of some reference point.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set inference radius</span>
<span class="n">training_radius</span> <span class="o">=</span> <span class="mf">0.15</span>

<span class="n">local_select_instructions</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;col&quot;</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;comp&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="n">training_radius</span><span class="p">},</span>
                             <span class="p">{</span><span class="s2">&quot;col&quot;</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;comp&quot;</span><span class="p">:</span> <span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="o">-</span><span class="n">training_radius</span><span class="p">}]</span>
                
</pre></div>
</div>
</div>
</div>
<p>The first argument <code class="docutils literal notranslate"><span class="pre">&quot;col&quot;</span></code> indicates which column in the dataframe we want to impose conditions on (in this case <code class="docutils literal notranslate"><span class="pre">&quot;x&quot;</span></code>), the <code class="docutils literal notranslate"><span class="pre">&quot;comp&quot;</span></code> arguments specifies a relation such as “greater than”, “less than”, etc… and the <code class="docutils literal notranslate"><span class="pre">&quot;val&quot;</span></code> argument specifies the value with which we want to compare our column with (in our case, the training radius).</p>
<p>Thus programmatically, the above list of commands will select data as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data_1</span> <span class="o">=</span> <span class="n">data_df</span><span class="p">[</span> <span class="p">(</span><span class="n">data_df</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">ref_point</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">training_radius</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_2</span> <span class="o">=</span> <span class="n">data_df</span><span class="p">[</span> <span class="p">(</span><span class="n">data_df</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">ref_point</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">training_radius</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_data</span> <span class="o">=</span> <span class="n">union</span><span class="p">(</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">ref_point</span></code> is some reference point, which, in the main loop, will correspond to the expert locations. The command <code class="docutils literal notranslate"><span class="pre">union</span></code> is a pseudo-function to take the intersection of members in <code class="docutils literal notranslate"><span class="pre">data_1</span></code> and <code class="docutils literal notranslate"><span class="pre">data_2</span></code>.</p>
<p>With this data selection instruction specified, we can now set the configuration for data as follows.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set data config</span>
<span class="n">data_config</span> <span class="o">=</span> <span class="n">DataConfig</span><span class="p">(</span><span class="n">data_source</span> <span class="o">=</span> <span class="n">data_df</span><span class="p">,</span>
                         <span class="n">obs_col</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span>
                         <span class="n">coords_col</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span>
                         <span class="n">local_select</span> <span class="o">=</span> <span class="n">local_select_instructions</span>
                        <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The argument <code class="docutils literal notranslate"><span class="pre">data_source</span></code> points to the dataframe where our data is stored, <code class="docutils literal notranslate"><span class="pre">obs_col</span></code> specifies the column in our dataframe corresponding to the measurements, <code class="docutils literal notranslate"><span class="pre">coords_col</span></code> specifies the column corresponding to the input coordinates, and <code class="docutils literal notranslate"><span class="pre">local_select</span></code> is where we put our instructions for local data selection.</p>
</section>
<section id="prediction-location-config">
<h3>4. Prediction location config<a class="headerlink" href="#prediction-location-config" title="Permalink to this heading">#</a></h3>
<p>Finally, we configure the prediction locations. This should include information about the test locations and the local inference region, where the local experts make predictions. The inference region is simply set to be a circular region around the expert location, with radius given by the inference radius.</p>
<p>First, we write the prediction locations into a dataframe.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up prediction locations as a dataframe</span>
<span class="n">prediction_locs</span> <span class="o">=</span> <span class="n">X_grid</span>
<span class="n">prediction_locs_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">X_grid</span><span class="p">})</span>

<span class="n">prediction_locs_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We can now set the configuration for prediction locations. We take the inference radius to be slightly larger than the training radius to include predictions on the boundaries.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inference_radius</span> <span class="o">=</span> <span class="n">training_radius</span> <span class="o">+</span> <span class="mf">1e-8</span>

<span class="n">pred_loc_config</span> <span class="o">=</span> <span class="n">PredictionLocsConfig</span><span class="p">(</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;from_dataframe&quot;</span><span class="p">,</span>
                                       <span class="n">df</span> <span class="o">=</span> <span class="n">prediction_locs_df</span><span class="p">,</span>
                                       <span class="n">max_dist</span> <span class="o">=</span> <span class="n">inference_radius</span>
                                       <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here, the <code class="docutils literal notranslate"><span class="pre">method</span></code> argument specifies how the prediction locations are selected. In our case this is <code class="docutils literal notranslate"><span class="pre">from_dataframe</span></code> and we specify the dataframe in the argument <code class="docutils literal notranslate"><span class="pre">df</span></code>. The <code class="docutils literal notranslate"><span class="pre">max_dist</span></code> argument specifies the inference radius around the expert location.</p>
</section>
</section>
<section id="run-experiment">
<h2>Run experiment<a class="headerlink" href="#run-experiment" title="Permalink to this heading">#</a></h2>
<p>We are now in shape to run our experiment. To do this, we initialise a <code class="docutils literal notranslate"><span class="pre">LocalExpertOI</span></code> object from the four config classes we created.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">GPSat.local_experts</span> <span class="kn">import</span> <span class="n">LocalExpertOI</span>

<span class="c1"># Set up local expert experiment</span>
<span class="n">locexp</span> <span class="o">=</span> <span class="n">LocalExpertOI</span><span class="p">(</span><span class="n">data_config</span> <span class="o">=</span> <span class="n">data_config</span><span class="p">,</span>
                       <span class="n">model_config</span> <span class="o">=</span> <span class="n">model_config</span><span class="p">,</span>
                       <span class="n">expert_loc_config</span> <span class="o">=</span> <span class="n">expert_loc_config</span><span class="p">,</span>
                       <span class="n">pred_loc_config</span> <span class="o">=</span> <span class="n">pred_loc_config</span><span class="p">)</span>
                       
</pre></div>
</div>
</div>
</div>
<p>Now, we just need to specify a path where we want to store our results and run an experiment with the <code class="docutils literal notranslate"><span class="pre">run()</span></code> method. The stored path should be a HDF5 file, which uses the extension <code class="docutils literal notranslate"><span class="pre">&quot;.h5&quot;</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># path to store results</span>
<span class="n">store_path</span> <span class="o">=</span> <span class="n">get_parent_path</span><span class="p">(</span><span class="s2">&quot;results&quot;</span><span class="p">,</span> <span class="s2">&quot;1d_tutorial_example.h5&quot;</span><span class="p">)</span>

<span class="c1"># for the purposes of a simple example, if store_path exists: delete it</span>
<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">store_path</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">store_path</span><span class="p">)</span>
    
<span class="c1"># run local expert optimal interpolation</span>
<span class="n">locexp</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">store_path</span><span class="o">=</span><span class="n">store_path</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can extract the results from the HDF5 with the <code class="docutils literal notranslate"><span class="pre">local_experts.get_results_from_h5file()</span></code> method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># extract, store in dict</span>
<span class="n">dfs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">GPSat</span><span class="o">.</span><span class="n">local_experts</span><span class="o">.</span><span class="n">get_results_from_h5file</span><span class="p">(</span><span class="n">store_path</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Check the results that are stored by accessing the keys of the dictionary <code class="docutils literal notranslate"><span class="pre">dfs</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dfs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We see tables storing the model parameters (<code class="docutils literal notranslate"><span class="pre">'kernel_variance'</span></code>, <code class="docutils literal notranslate"><span class="pre">'lengthscales'</span></code>, <code class="docutils literal notranslate"><span class="pre">'likelihood_variance'</span></code>), the full configuration used to run the experiment stored in json format (<code class="docutils literal notranslate"><span class="pre">'oi_config'</span></code>), model predictions (<code class="docutils literal notranslate"><span class="pre">'preds'</span></code>) and details of the experiment run such as run time, device name, etc… (<code class="docutils literal notranslate"><span class="pre">'run_details'</span></code>).</p>
<p>Let’s check the <code class="docutils literal notranslate"><span class="pre">'preds'</span></code> table storing the model predictions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dfs</span><span class="p">[</span><span class="s1">&#39;preds&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>As in the previous tutorial, we can glue overlapping predictions from different experts by running the <code class="docutils literal notranslate"><span class="pre">glue_local_predictions_1d()</span></code> method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">glued_preds</span> <span class="o">=</span> <span class="n">glue_local_predictions_1d</span><span class="p">(</span><span class="n">preds_df</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">[</span><span class="s1">&#39;preds&#39;</span><span class="p">],</span>
                                        <span class="n">pred_loc_col</span> <span class="o">=</span> <span class="s1">&#39;pred_loc_x&#39;</span><span class="p">,</span>
                                        <span class="n">xprt_loc_col</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span>
                                        <span class="n">vars_to_glue</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;f*&#39;</span><span class="p">,</span> <span class="s1">&#39;f*_var&#39;</span><span class="p">],</span>
                                        <span class="n">inference_radius</span> <span class="o">=</span> <span class="n">inference_radius</span><span class="p">)</span>
<span class="n">glued_preds</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We plot the results below</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Extract glued mean and variance predictions</span>
<span class="n">f_mean</span> <span class="o">=</span> <span class="n">glued_preds</span><span class="p">[</span><span class="s1">&#39;f*&#39;</span><span class="p">]</span>
<span class="n">f_var</span> <span class="o">=</span> <span class="n">glued_preds</span><span class="p">[</span><span class="s1">&#39;f*_var&#39;</span><span class="p">]</span>
<span class="n">f_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f_var</span><span class="p">)</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">glued_preds</span><span class="p">[</span><span class="s1">&#39;pred_loc_x&#39;</span><span class="p">]</span>

<span class="c1"># Plot results</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_truth</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ground truth&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">f_mean</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Glued predictions (2 experts)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">f_mean</span><span class="o">-</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std</span><span class="p">,</span> <span class="n">f_mean</span><span class="o">+</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="n">xvals</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.45</span><span class="p">]</span>
<span class="n">yvals</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">xerr</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">elinewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">barsabove</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">capsize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Local expert locations&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.4</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>In the above, we have also illustrated the local expert locations (blue circle) and the inference regions (blue horizontal bars).</p>
<p>Below, we assess the performance of the model.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean squared error: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">f_truth</span> <span class="o">-</span> <span class="n">f_mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean log likelihood: </span><span class="si">{</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">f_truth</span><span class="p">,</span> <span class="n">f_mean</span><span class="p">,</span> <span class="n">f_std</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="using-more-local-experts">
<h2>Using more local experts<a class="headerlink" href="#using-more-local-experts" title="Permalink to this heading">#</a></h2>
<p>Finally, let’s see what happens when we double the number of local experts. Below, we set up the configurations for an experiment using the expert locations at x = [0.2, 0.3, 0.4, 0.5] and training radius = 0.1.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set new expert locations</span>
<span class="n">xprt_locs</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>

<span class="c1"># Set training and inference radii</span>
<span class="n">training_radius</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">inference_radius</span> <span class="o">=</span> <span class="n">training_radius</span> <span class="o">+</span> <span class="mf">1e-8</span>

<span class="c1"># Set up configs</span>
<span class="n">expert_loc_config</span> <span class="o">=</span> <span class="n">ExpertLocsConfig</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">xprt_locs</span><span class="p">}))</span>

<span class="n">model_config</span> <span class="o">=</span> <span class="n">ModelConfig</span><span class="p">(</span><span class="n">oi_model</span><span class="o">=</span><span class="s2">&quot;sklearnGPRModel&quot;</span><span class="p">,</span>
                           <span class="n">init_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;likelihood_variance&quot;</span><span class="p">:</span> <span class="n">noise_std</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                                        <span class="s2">&quot;kernel&quot;</span><span class="p">:</span> <span class="s1">&#39;RBF&#39;</span><span class="p">,</span>
                                        <span class="s2">&quot;verbose&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
                           <span class="p">)</span>

<span class="n">data_config</span> <span class="o">=</span> <span class="n">DataConfig</span><span class="p">(</span><span class="n">data_source</span><span class="o">=</span><span class="n">data_df</span><span class="p">,</span>
                         <span class="n">obs_col</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span>
                         <span class="n">coords_col</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span>
                         <span class="n">local_select</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;col&quot;</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;comp&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="n">training_radius</span><span class="p">},</span>
                                       <span class="p">{</span><span class="s2">&quot;col&quot;</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;comp&quot;</span><span class="p">:</span> <span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="o">-</span><span class="n">training_radius</span><span class="p">}]</span>
                        <span class="p">)</span>

<span class="n">pred_loc_config</span> <span class="o">=</span> <span class="n">PredictionLocsConfig</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;from_dataframe&quot;</span><span class="p">,</span>
                                       <span class="n">df</span><span class="o">=</span><span class="n">prediction_locs_df</span><span class="p">,</span>
                                       <span class="n">max_dist</span><span class="o">=</span><span class="n">inference_radius</span>
                                       <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We run this experiment below using <code class="docutils literal notranslate"><span class="pre">LocalExpertOI</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up local expert experiment</span>
<span class="n">locexp</span> <span class="o">=</span> <span class="n">LocalExpertOI</span><span class="p">(</span><span class="n">data_config</span> <span class="o">=</span> <span class="n">data_config</span><span class="p">,</span>
                       <span class="n">model_config</span> <span class="o">=</span> <span class="n">model_config</span><span class="p">,</span>
                       <span class="n">expert_loc_config</span> <span class="o">=</span> <span class="n">expert_loc_config</span><span class="p">,</span>
                       <span class="n">pred_loc_config</span> <span class="o">=</span> <span class="n">pred_loc_config</span><span class="p">)</span>

<span class="c1"># path to store results</span>
<span class="n">store_path</span> <span class="o">=</span> <span class="n">get_parent_path</span><span class="p">(</span><span class="s2">&quot;results&quot;</span><span class="p">,</span> <span class="s2">&quot;1d_tutorial_example.h5&quot;</span><span class="p">)</span>

<span class="c1"># for the purposes of a simple example, if store_path exists: delete it</span>
<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">store_path</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">store_path</span><span class="p">)</span>
    
<span class="c1"># run local expert optimal interpolation</span>
<span class="n">locexp</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">store_path</span><span class="o">=</span><span class="n">store_path</span><span class="p">,</span> <span class="n">store_every</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Plot results:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># extract, store in dict</span>
<span class="n">dfs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">GPSat</span><span class="o">.</span><span class="n">local_experts</span><span class="o">.</span><span class="n">get_results_from_h5file</span><span class="p">(</span><span class="n">store_path</span><span class="p">)</span>

<span class="n">glued_preds</span> <span class="o">=</span> <span class="n">glue_local_predictions_1d</span><span class="p">(</span><span class="n">preds_df</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">[</span><span class="s1">&#39;preds&#39;</span><span class="p">],</span>
                                        <span class="n">pred_loc_col</span> <span class="o">=</span> <span class="s1">&#39;pred_loc_x&#39;</span><span class="p">,</span>
                                        <span class="n">xprt_loc_col</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span>
                                        <span class="n">vars_to_glue</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;f*&#39;</span><span class="p">,</span> <span class="s1">&#39;f*_var&#39;</span><span class="p">],</span>
                                        <span class="n">inference_radius</span> <span class="o">=</span> <span class="n">inference_radius</span><span class="p">)</span>

<span class="c1"># Extract glued mean and variance predictions</span>
<span class="n">f_mean</span> <span class="o">=</span> <span class="n">glued_preds</span><span class="p">[</span><span class="s1">&#39;f*&#39;</span><span class="p">]</span>
<span class="n">f_var</span> <span class="o">=</span> <span class="n">glued_preds</span><span class="p">[</span><span class="s1">&#39;f*_var&#39;</span><span class="p">]</span>
<span class="n">f_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f_var</span><span class="p">)</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">glued_preds</span><span class="p">[</span><span class="s1">&#39;pred_loc_x&#39;</span><span class="p">]</span>

<span class="c1"># Plot results</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">f_truth</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ground truth&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">f_mean</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C4&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Glued predictions (4 experts)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">f_mean</span><span class="o">-</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std</span><span class="p">,</span> <span class="n">f_mean</span><span class="o">+</span><span class="mf">1.96</span><span class="o">*</span><span class="n">f_std</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C4&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="n">xvals</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
<span class="n">yvals</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">xerr</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">elinewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">barsabove</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">capsize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Local expert locations&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.4</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We see that the results look much better and this is also reflected in the metrics:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean squared error: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">f_truth</span> <span class="o">-</span> <span class="n">f_mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean log likelihood: </span><span class="si">{</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">f_truth</span><span class="p">,</span> <span class="n">f_mean</span><span class="p">,</span> <span class="n">f_std</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Note:</strong> To achieve the best performance using local experts model, each local experts should have sufficiently many data points to prevent overfitting on a particular region. However, if this happens, we can prevent this by <em>hyperparameter smoothing</em>.</p>
<p><strong>Note:</strong> In <code class="docutils literal notranslate"><span class="pre">GPSat</span></code>, we have not yet considered learning the optimal distribution of expert locations and the corresponding inference/training radii that best fit the data. We typically assume the expert locations to be distributed on an even grid and use the same inference/training at every expert locations. However it might be interesting in the future to consider the learning of such hyperparameters to further improve performance.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="d-interpolation-of-abc-satellite-data">
<h1>2D interpolation of ABC satellite data<a class="headerlink" href="#d-interpolation-of-abc-satellite-data" title="Permalink to this heading">#</a></h1>
<p>Now, we look at a more practical example to generate gridded predictions of the sea-ice freeboard from satellite data using <code class="docutils literal notranslate"><span class="pre">GPSat</span></code>. For the satellite data, we use a sample of the Sentinel 3A and 3B data as well as CryoSat-2 data (referred to as A, B and C respectively).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">GPSat</span> <span class="kn">import</span> <span class="n">get_data_path</span><span class="p">,</span> <span class="n">get_parent_path</span>
<span class="kn">from</span> <span class="nn">GPSat.dataprepper</span> <span class="kn">import</span> <span class="n">DataPrep</span>
<span class="kn">from</span> <span class="nn">GPSat.utils</span> <span class="kn">import</span> <span class="n">WGS84toEASE2_New</span><span class="p">,</span> <span class="n">EASE2toWGS84_New</span><span class="p">,</span> <span class="n">cprint</span><span class="p">,</span> <span class="n">grid_2d_flatten</span><span class="p">,</span> <span class="n">get_weighted_values</span>
<span class="kn">from</span> <span class="nn">GPSat.local_experts</span> <span class="kn">import</span> <span class="n">LocalExpertOI</span><span class="p">,</span> <span class="n">get_results_from_h5file</span>
<span class="kn">from</span> <span class="nn">GPSat.plot_utils</span> <span class="kn">import</span> <span class="n">plot_pcolormesh</span><span class="p">,</span> <span class="n">get_projection</span><span class="p">,</span> <span class="n">plot_pcolormesh_from_results_data</span>
<span class="kn">from</span> <span class="nn">GPSat.config_dataclasses</span> <span class="kn">import</span> <span class="n">DataConfig</span><span class="p">,</span> <span class="n">ModelConfig</span><span class="p">,</span> <span class="n">PredictionLocsConfig</span><span class="p">,</span> <span class="n">ExpertLocsConfig</span>
<span class="kn">from</span> <span class="nn">GPSat.postprocessing</span> <span class="kn">import</span> <span class="n">glue_local_predictions_2d</span>
</pre></div>
</div>
</div>
</div>
<p>We read in the raw ABC satellite data saved in this repo for demo purposes. We combine the data sources into a single dataframe.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># read in all the *_RAW.csv files in data/example</span>
<span class="c1"># - get files to read</span>
<span class="n">raw_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_data_path</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">get_data_path</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">))</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;_RAW\.csv$&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>

<span class="c1"># read in, add source col</span>
<span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">raw_files</span><span class="p">:</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;_RAW\.csv$&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
    <span class="n">sat_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="n">sat_data</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span>
    <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sat_data</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Here, the variable <code class="docutils literal notranslate"><span class="pre">z</span></code> signifies the freeboard measurement that we wish to interpolate. For convenience, we will convert the <code class="docutils literal notranslate"><span class="pre">lon</span></code>, <code class="docutils literal notranslate"><span class="pre">lat</span></code> variables into <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> EASE(2) grid coordinates and the <code class="docutils literal notranslate"><span class="pre">datetime</span></code> column to <code class="docutils literal notranslate"><span class="pre">t</span></code> UTC days.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># convert lon, lat, datetime to x, y, t - to be used as the coordinate space</span>
<span class="c1"># - x,y are in meters, t in days</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WGS84toEASE2_New</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span> <span class="n">lat</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">],</span> <span class="n">lat_0</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">lon_0</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[D]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We bin the raw data to a 50km grid to reduce the total data size.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># bin by date, source to a 50x50km grid</span>
<span class="c1"># - returns a DataSet</span>
<span class="n">bin_ds</span> <span class="o">=</span> <span class="n">DataPrep</span><span class="o">.</span><span class="n">bin_data_by</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">0.35</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.65</span><span class="p">)],</span>
                              <span class="n">by_cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">],</span>
                              <span class="n">val_col</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">,</span>
                              <span class="n">x_col</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
                              <span class="n">y_col</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span>
                              <span class="n">grid_res</span><span class="o">=</span><span class="mi">50_000</span><span class="p">,</span>
                              <span class="n">x_range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">4500000.0</span><span class="p">,</span> <span class="mf">4500000.0</span><span class="p">],</span>
                              <span class="n">y_range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">4500000.0</span><span class="p">,</span> <span class="mf">4500000.0</span><span class="p">])</span>

<span class="c1"># convert bin data to DataFrame</span>
<span class="c1"># - removing all the nans that would be added at grid locations away from data</span>
<span class="n">bin_df</span> <span class="o">=</span> <span class="n">bin_ds</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

<span class="n">bin_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Below we plot the binned data:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># this will plot all observations, some on top of each other</span>
<span class="n">bin_df</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span> <span class="n">bin_df</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">EASE2toWGS84_New</span><span class="p">(</span><span class="n">bin_df</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">bin_df</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">])</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="n">get_projection</span><span class="p">(</span><span class="s1">&#39;north&#39;</span><span class="p">))</span>

<span class="n">plot_pcolormesh</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                <span class="n">lon</span><span class="o">=</span><span class="n">bin_df</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span>
                <span class="n">lat</span><span class="o">=</span><span class="n">bin_df</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">],</span>
                <span class="n">plot_data</span><span class="o">=</span><span class="n">bin_df</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">],</span>
                <span class="n">title</span><span class="o">=</span><span class="s2">&quot;example: binned obs&quot;</span><span class="p">,</span>
                <span class="n">scatter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">s</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span>
                <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">90</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<section id="setting-up-configurations">
<h2>Setting up configurations<a class="headerlink" href="#setting-up-configurations" title="Permalink to this heading">#</a></h2>
<p>Now, we set up the configuration dataclasses for interpolating this data using local GP experts. For the expert locations, we use points on an evenly spaced 200km grid. For this tutorial, we will only consider interpolating on a small square region around the pole.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># - spaced every 200km for some x,y range</span>
<span class="n">xy_grid</span> <span class="o">=</span> <span class="n">grid_2d_flatten</span><span class="p">(</span><span class="n">x_range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">500000.0</span><span class="p">,</span> <span class="mf">500000.0</span><span class="p">],</span>
                          <span class="n">y_range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">500000.0</span><span class="p">,</span> <span class="mf">500000.0</span><span class="p">],</span>
                          <span class="n">step_size</span><span class="o">=</span><span class="mi">200_000</span><span class="p">)</span>

<span class="c1"># store in dataframe</span>
<span class="n">eloc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">xy_grid</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">])</span>

<span class="c1"># add a time coordinate</span>
<span class="n">eloc</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Local expert locations:&quot;</span><span class="p">)</span>
<span class="n">eloc</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We plot this below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># plot expert locations</span>
<span class="n">eloc</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span> <span class="n">eloc</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">EASE2toWGS84_New</span><span class="p">(</span><span class="n">eloc</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">eloc</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">])</span>


<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="n">get_projection</span><span class="p">(</span><span class="s1">&#39;north&#39;</span><span class="p">))</span>

<span class="n">plot_pcolormesh</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                <span class="n">lon</span><span class="o">=</span><span class="n">eloc</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span>
                <span class="n">lat</span><span class="o">=</span><span class="n">eloc</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">],</span>
                <span class="n">plot_data</span><span class="o">=</span><span class="n">eloc</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">],</span>
                <span class="n">title</span><span class="o">=</span><span class="s2">&quot;expert locations&quot;</span><span class="p">,</span>
                <span class="n">scatter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">s</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">90</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>For the prediction locations, we use points on a finer 5km grid.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># - spaced every 5km</span>
<span class="n">xy_grid</span> <span class="o">=</span> <span class="n">grid_2d_flatten</span><span class="p">(</span><span class="n">x_range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">500000.0</span><span class="p">,</span> <span class="mf">500000.0</span><span class="p">],</span>
                          <span class="n">y_range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">500000.0</span><span class="p">,</span> <span class="mf">500000.0</span><span class="p">],</span>
                          <span class="n">step_size</span><span class="o">=</span><span class="mi">5_000</span><span class="p">)</span>

<span class="c1"># store in dataframe</span>
<span class="c1"># NOTE: the missing &#39;t&#39; coordinate will be determine by the expert location</span>
<span class="c1"># - alternatively the prediction location can be specified</span>
<span class="n">ploc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">xy_grid</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">])</span>

<span class="c1"># Add lon-lat measurements</span>
<span class="n">ploc</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span> <span class="n">ploc</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">EASE2toWGS84_New</span><span class="p">(</span><span class="n">ploc</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">ploc</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Prediction locations:&quot;</span><span class="p">)</span>
<span class="n">ploc</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Again we plot this below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># plot prediction locations</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="n">get_projection</span><span class="p">(</span><span class="s1">&#39;north&#39;</span><span class="p">))</span>

<span class="n">plot_pcolormesh</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                <span class="n">lon</span><span class="o">=</span><span class="n">ploc</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span>
                <span class="n">lat</span><span class="o">=</span><span class="n">ploc</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">],</span>
                <span class="n">plot_data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ploc</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">),</span> <span class="c1">#np.arange(len(ploc)),</span>
                <span class="n">title</span><span class="o">=</span><span class="s2">&quot;prediction locations&quot;</span><span class="p">,</span>
                <span class="n">scatter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">s</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">90</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We now set up configurations for Local Expert OI</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set training and inference radius</span>
<span class="n">training_radius</span> <span class="o">=</span> <span class="mi">300_000</span>   <span class="c1"># 300km</span>
<span class="n">inference_radius</span> <span class="o">=</span> <span class="mi">200_000</span>  <span class="c1"># 200km</span>

<span class="c1"># Local expert locations config</span>
<span class="n">local_expert</span> <span class="o">=</span> <span class="n">ExpertLocsConfig</span><span class="p">(</span><span class="n">source</span> <span class="o">=</span> <span class="n">eloc</span><span class="p">)</span>

<span class="c1"># Model config</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">ModelConfig</span><span class="p">(</span><span class="n">oi_model</span> <span class="o">=</span> <span class="s2">&quot;GPflowGPRModel&quot;</span><span class="p">,</span> <span class="c1"># Use GPflow GPR model</span>
                    <span class="n">init_params</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="c1"># normalise xy coordinates by 50km</span>
                        <span class="s2">&quot;coords_scale&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">50_000</span><span class="p">,</span> <span class="mi">50_000</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="p">},</span>
                    <span class="n">constraints</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="c1"># set bounds on the lengthscale hyperparameters</span>
                        <span class="s2">&quot;lengthscales&quot;</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s2">&quot;low&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1e-08</span><span class="p">,</span> <span class="mf">1e-08</span><span class="p">,</span> <span class="mf">1e-08</span><span class="p">],</span>
                            <span class="s2">&quot;high&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">600_000</span><span class="p">,</span> <span class="mi">600_000</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
                        <span class="p">}</span>
                        <span class="p">}</span>
                    <span class="p">)</span>

<span class="c1"># Data config</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">DataConfig</span><span class="p">(</span><span class="n">data_source</span> <span class="o">=</span> <span class="n">bin_df</span><span class="p">,</span>
                  <span class="n">obs_col</span> <span class="o">=</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span>
                  <span class="n">coords_col</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">],</span>
                  <span class="n">local_select</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="c1"># Select data within 300km and ± 4 days of the expert location</span>
                    <span class="p">{</span><span class="s2">&quot;col&quot;</span><span class="p">:</span> <span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="s2">&quot;comp&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
                    <span class="p">{</span><span class="s2">&quot;col&quot;</span><span class="p">:</span> <span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="s2">&quot;comp&quot;</span><span class="p">:</span> <span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">4</span><span class="p">},</span>
                    <span class="p">{</span><span class="s2">&quot;col&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="s2">&quot;comp&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="n">training_radius</span><span class="p">}</span>
                  <span class="p">]</span>
                <span class="p">)</span>

<span class="c1"># Prediction locs config</span>
<span class="n">pred_loc</span> <span class="o">=</span> <span class="n">PredictionLocsConfig</span><span class="p">(</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;from_dataframe&quot;</span><span class="p">,</span>
                                <span class="n">df</span> <span class="o">=</span> <span class="n">ploc</span><span class="p">,</span>
                                <span class="n">max_dist</span> <span class="o">=</span> <span class="n">inference_radius</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Set up Local Expert OI object from these configs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">locexp</span> <span class="o">=</span> <span class="n">LocalExpertOI</span><span class="p">(</span><span class="n">expert_loc_config</span> <span class="o">=</span> <span class="n">local_expert</span><span class="p">,</span>
                       <span class="n">data_config</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span>
                       <span class="n">model_config</span> <span class="o">=</span> <span class="n">model</span><span class="p">,</span>
                       <span class="n">pred_loc_config</span> <span class="o">=</span> <span class="n">pred_loc</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Specify a file to store results and run the experiment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># path to store results</span>
<span class="n">store_path</span> <span class="o">=</span> <span class="n">get_parent_path</span><span class="p">(</span><span class="s2">&quot;results&quot;</span><span class="p">,</span> <span class="s2">&quot;inline_example.h5&quot;</span><span class="p">)</span>

<span class="c1"># for the purposes of a simple example, if store_path exists: delete it</span>
<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">store_path</span><span class="p">):</span>
    <span class="n">cprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;removing: </span><span class="si">{</span><span class="n">store_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">store_path</span><span class="p">)</span>

<span class="c1"># run optimal interpolation</span>
<span class="n">locexp</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">store_path</span><span class="o">=</span><span class="n">store_path</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Extract the results from the store path:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># extract, store in dict</span>
<span class="n">dfs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_results_from_h5file</span><span class="p">(</span><span class="n">store_path</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tables in results file: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">dfs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">preds_data</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">[</span><span class="s2">&quot;preds&quot;</span><span class="p">]</span>

<span class="n">preds_data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>As before there are going to be overlapping predictions coming from different local experts hence we glue them together using the <code class="docutils literal notranslate"><span class="pre">glue_local_predictions_2d()</span></code> method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># multiple local experts may make predictions at the same prediction location (pred_loc).</span>
<span class="c1"># - for each prediction at a given location, take we weighted combination</span>
<span class="c1"># - weights being a function of the distance to each local expert that made a prediction at a given location.</span>

<span class="n">plt_data</span> <span class="o">=</span> <span class="n">glue_local_predictions_2d</span><span class="p">(</span><span class="n">preds_df</span><span class="o">=</span><span class="n">preds_data</span><span class="p">,</span>
                                     <span class="n">pred_loc_cols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pred_loc_x&quot;</span><span class="p">,</span> <span class="s2">&quot;pred_loc_y&quot;</span><span class="p">],</span>
                                     <span class="n">xprt_loc_cols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span>
                                     <span class="n">vars_to_glue</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;f*&quot;</span><span class="p">,</span> <span class="s2">&quot;f*_var&quot;</span><span class="p">],</span>
                                     <span class="n">inference_radius</span><span class="o">=</span><span class="n">inference_radius</span><span class="p">)</span>

<span class="n">plt_data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We then plot this result:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># add convert x,y to lon,lat</span>
<span class="n">plt_data</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span> <span class="n">plt_data</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">EASE2toWGS84_New</span><span class="p">(</span><span class="n">plt_data</span><span class="p">[</span><span class="s1">&#39;pred_loc_x&#39;</span><span class="p">],</span> <span class="n">plt_data</span><span class="p">[</span><span class="s1">&#39;pred_loc_y&#39;</span><span class="p">])</span>


<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="n">get_projection</span><span class="p">(</span><span class="s1">&#39;north&#39;</span><span class="p">))</span>
<span class="n">plot_pcolormesh_from_results_data</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                                  <span class="n">dfs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;preds&quot;</span><span class="p">:</span> <span class="n">plt_data</span><span class="p">},</span>
                                  <span class="n">table</span><span class="o">=</span><span class="s1">&#39;preds&#39;</span><span class="p">,</span>
                                  <span class="n">val_col</span><span class="o">=</span><span class="s2">&quot;f*&quot;</span><span class="p">,</span>
                                  <span class="n">scatter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">x_col</span><span class="o">=</span><span class="s1">&#39;pred_loc_x&#39;</span><span class="p">,</span>
                                  <span class="n">y_col</span><span class="o">=</span><span class="s1">&#39;pred_loc_y&#39;</span><span class="p">,</span>
                                  <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span>
                                  <span class="n">plot_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;f*: predictions&quot;</span><span class="p">})</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="Chapter2_IntrotoGaussianProcesses.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Introduction to Gaussian Processes</p>
      </div>
    </a>
    <a class="right-next"
       href="Chapter_2_GPSat_along_track-3.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">GPSat Along-Track Interpolation</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Introduction to GPSat</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#gaussian-processes">Gaussian processes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-likelihood">The likelihood</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#prediction">Prediction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#training">Training</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#using-gpus-to-accelerate-training-and-inference">Using GPUs to accelerate training and inference</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#gpsat-modelling-with-local-gp-experts-a-1-d-case-study-part-1">GPSat modelling with local GP experts: A 1-D case study (Part 1)</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#local-gp-experts">Local GP experts</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#gpsat-modelling-with-local-gp-experts-a-1-d-case-study-part-2">GPSat modelling with local GP experts: A 1-D case study (Part 2)</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#configuration-dataclasses">Configuration dataclasses</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#local-expert-config">1. Local expert config</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#model-config">2. Model config</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#data-config">3. Data config</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#prediction-location-config">4. Prediction location config</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#run-experiment">Run experiment</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-more-local-experts">Using more local experts</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#d-interpolation-of-abc-satellite-data">2D interpolation of ABC satellite data</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#setting-up-configurations">Setting up configurations</a></li>
</ul>
</li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Michel Tsamados/Weibin Chen
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=365ca57ee442770a23c6"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=365ca57ee442770a23c6"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>